# I256 - Signed 256-bit Integer

The `I256` type represents a signed 256-bit integer, allowing both positive and negative values. It's the signed counterpart to `U256` and is essential for arithmetic operations that require negative numbers in AssemblyScript Stylus smart contracts.

## Import

```typescript
import { I256, I256Factory, U256 } from '@as-stylus/as-stylus';
```

## Overview

I256 provides:
- Range: -2^255 to 2^255 - 1
- Support for negative values unlike U256
- Basic arithmetic operations (add, subtract)
- Comparison operations that handle negative values correctly
- Sign detection and negation operations
- Conversion utilities with U256

## Available Operations

Based on the interface, I256 supports these operations:

### Arithmetic Operations
- `add(other: I256): I256` - Addition
- `sub(other: I256): I256` - Subtraction

### Comparison Operations
- `greaterThan(other: I256): boolean`
- `greaterThanOrEqual(other: I256): boolean`
- `lessThan(other: I256): boolean`
- `lessThanOrEqual(other: I256): boolean`
- `equal(other: I256): boolean`
- `notEqual(other: I256): boolean`

### Sign Operations
- `isNegative(): boolean` - Check if value is negative
- `negate(): I256` - Return the negated value
- `abs(): U256` - Return absolute value as U256

### Conversion
- `toString(): string` - Convert to string representation

### Factory Methods
- `I256Factory.create(): I256` - Create new I256 instance (likely zero)
- `I256Factory.fromString(value: string): I256` - Create from string
- `I256Factory.fromU256(value: U256): I256` - Create from U256

## Creation and Basic Usage

### Creating I256 Values

```typescript
import { I256, I256Factory, U256, U256Factory } from '@as-stylus/as-stylus';

// Create new I256 instance (zero)
const zero = I256Factory.create();

// Create from string
const positiveValue = I256Factory.fromString("42");
const negativeValue = I256Factory.fromString("-42");
const largeNegative = I256Factory.fromString("-1000000000000000000");

// Create from U256
const u256Value = U256Factory.fromString("100");
const fromU256 = I256Factory.fromU256(u256Value);
```

### Basic Operations

```typescript
const a = I256Factory.fromString("100");
const b = I256Factory.fromString("-30");

// Arithmetic operations
const sum = a.add(b);        // 70
const diff = a.sub(b);       // 130

// Sign operations
const isNegB = b.isNegative();    // true
const negatedB = b.negate();      // 30
const absoluteB = b.abs();        // U256 with value 30
```

## Comparison Operations

I256 provides proper signed comparison operations:

```typescript
const positive = I256Factory.fromString("10");
const negative = I256Factory.fromString("-5");
const zero = I256Factory.create();

// Comparison methods
const isLess = negative.lessThan(positive);           // true
const isLessEq = negative.lessThanOrEqual(zero);      // true
const isGreater = positive.greaterThan(negative);     // true
const isGreaterEq = zero.greaterThanOrEqual(negative); // true
const isEqual = positive.equal(I256Factory.fromString("10")); // true
const isNotEqual = positive.notEqual(negative);       // true

// Sign checking
const isNeg = negative.isNegative(); // true
const isPosOrZero = !positive.isNegative(); // true for positive or zero
```

## Contract Integration

### Storage Operations

```typescript
import { Storage } from '@as-stylus/as-stylus';

@Contract
class SignedCounter {
    private value: Storage<I256>;
    
    constructor() {
        this.value = new Storage<I256>();
        this.value.set(I256Factory.create()); // Initialize to 0
    }
    
    @External
    increment(): void {
        const current = this.value.get();
        const one = I256Factory.fromString("1");
        const newValue = current.add(one);
        this.value.set(newValue);
    }
    
    @External
    decrement(): void {
        const current = this.value.get();
        const one = I256Factory.fromString("1");
        const newValue = current.sub(one);
        this.value.set(newValue);
    }
    
    @External
    addValue(amount: I256): void {
        const current = this.value.get();
        const newValue = current.add(amount);
        this.value.set(newValue);
    }
    
    @View
    getValue(): I256 {
        return this.value.get();
    }
    
    @View
    isNegative(): boolean {
        return this.value.get().isNegative();
    }
    
    @View
    getAbsoluteValue(): U256 {
        return this.value.get().abs();
    }
}
```

### Event Logging

```typescript
@Event
class BalanceChanged {
    oldBalance: I256;
    newBalance: I256;
    change: I256;
    isPositiveChange: boolean;
}

@External
updateBalance(newBalance: I256): void {
    const oldBalance = this.balance.get();
    const change = newBalance.sub(oldBalance);
    
    // Emit detailed change event
    const event = new BalanceChanged();
    event.oldBalance = oldBalance;
    event.newBalance = newBalance;
    event.change = change;
    event.isPositiveChange = !change.isNegative();
    event.emit();
    
    this.balance.set(newBalance);
}
```

## Safe Operations

### Sign Validation

```typescript
function requirePositive(value: I256): void {
    if (value.isNegative() || value.equal(I256Factory.create())) {
        revert("Value must be positive");
    }
}

function requireNonNegative(value: I256): void {
    if (value.isNegative()) {
        revert("Value cannot be negative");
    }
}
```

### Range Validation

```typescript
function validateRange(value: I256, min: I256, max: I256): void {
    if (value.lessThan(min)) {
        revert(`Value ${value.toString()} below minimum ${min.toString()}`);
    }
    if (value.greaterThan(max)) {
        revert(`Value ${value.toString()} above maximum ${max.toString()}`);
    }
}
```

## Type Conversions

### I256 to U256 Conversion

```typescript
function i256ToU256Safe(value: I256): U256 {
    if (value.isNegative()) {
        revert("Cannot convert negative I256 to U256");
    }
    return value.abs();
}
```

### U256 to I256 Conversion

```typescript
function u256ToI256Safe(value: U256): I256 {
    // Note: This is a simplified example
    // In practice, you'd need to check if the U256 value
    // exceeds the maximum positive I256 value
    return I256Factory.fromU256(value);
}
```

## Error Handling

### Common Error Patterns

```typescript
@Error
class InvalidSignedAmount {
    provided: I256;
    reason: string;
}

@Error
class SignMismatch {
    expected: string; // "positive" or "negative"
    actual: I256;
}

// Usage in validation functions
function requirePositiveAmount(amount: I256): void {
    if (amount.isNegative() || amount.equal(I256Factory.create())) {
        const error = new InvalidSignedAmount();
        error.provided = amount;
        error.reason = "Amount must be positive";
        error.revert();
    }
}

function requireNegativeAmount(amount: I256): void {
    if (!amount.isNegative()) {
        const error = new SignMismatch();
        error.expected = "negative";
        error.actual = amount;
        error.revert();
    }
}
```

## Best Practices

### Constants and Readability

```typescript
// Define commonly used values
const ZERO = I256Factory.create();
const ONE = I256Factory.fromString("1");
const MINUS_ONE = I256Factory.fromString("-1");

// Descriptive function names
function isPositive(value: I256): boolean {
    return !value.isNegative() && !value.equal(ZERO);
}

function isZero(value: I256): boolean {
    return value.equal(ZERO);
}

function isNegativeOrZero(value: I256): boolean {
    return value.isNegative() || value.equal(ZERO);
}
```

### Gas Optimization

```typescript
// Cache frequently used values
const zero = I256Factory.create();

// Efficient sign-based operations
function applySign(amount: I256, makeNegative: boolean): I256 {
    if (makeNegative && !amount.isNegative()) {
        return amount.negate();
    } else if (!makeNegative && amount.isNegative()) {
        return amount.negate();
    }
    return amount;
}
```

## Common Use Cases

- **Financial calculations** with support for negative amounts (debts, losses)
- **Delta calculations** (changes, differences, trends)  
- **Counter systems** that can go negative (vote differences, balance changes)
- **Signed arithmetic** in DeFi protocols (PnL calculations)
- **Mathematical operations** requiring full signed range

## Limitations

The current I256 interface does NOT include:
- Multiplication or division operations
- Modulo operations
- Bitwise operations
- Power/exponential functions
- Complex mathematical functions

For operations requiring these features, you'll need to implement them using the available add, sub, and sign operations, or wait for expanded interface support.

## Related Types

- **U256**: Unsigned counterpart for positive-only values
- **Address**: For Ethereum addresses and contract references  
- **String**: For text-based data and user interfaces
- **Boolean**: For logical operations and conditional logic 