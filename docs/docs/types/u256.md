# U256 - Unsigned 256-bit Integer

The `U256` type represents an unsigned 256-bit integer, the fundamental numeric type for handling large values in AssemblyScript Stylus smart contracts. It provides essential arithmetic and comparison operations for financial calculations and numeric logic.

## Import

```typescript
import { U256, U256Factory } from '@as-stylus/as-stylus';
```

## Overview

U256 provides:
- Range: 0 to 2^256 - 1
- Basic arithmetic operations (add, subtract, modulo)
- Comparison operations for conditional logic
- String conversion for display and formatting
- Factory methods for creation

## Available Operations

Based on the interface, U256 supports these operations:

### Arithmetic Operations
- `add(other: U256): U256` - Addition
- `sub(other: U256): U256` - Subtraction  
- `modulo(other: U256): U256` - Modulo (remainder)

### Comparison Operations
- `greaterThan(other: U256): boolean`
- `greaterThanOrEqual(other: U256): boolean`
- `lessThan(other: U256): boolean`
- `lessThanOrEqual(other: U256): boolean`
- `equal(other: U256): boolean`
- `notEqual(other: U256): boolean`

### Conversion
- `toString(): string` - Convert to string representation

### Factory Methods
- `U256Factory.create(): U256` - Create new U256 instance
- `U256Factory.fromString(value: string): U256` - Create from string

## Creation and Basic Usage

### Creating U256 Values

```typescript
import { U256, U256Factory } from '@as-stylus/as-stylus';

// Create new U256 instance
const zero = U256Factory.create();

// Create from string
const largeNumber = U256Factory.fromString("1000000000000000000000");
const smallNumber = U256Factory.fromString("42");
```

### Basic Arithmetic

```typescript
const a = U256Factory.fromString("100");
const b = U256Factory.fromString("30");

// Addition
const sum = a.add(b); // 130

// Subtraction
const difference = a.sub(b); // 70

// Modulo
const remainder = a.modulo(b); // 10
```

### Comparison Operations

```typescript
const num1 = U256Factory.fromString("100");
const num2 = U256Factory.fromString("50");

// All comparison operations
const isGreater = num1.greaterThan(num2);          // true
const isGreaterEqual = num1.greaterThanOrEqual(num2); // true
const isLess = num1.lessThan(num2);                // false
const isLessEqual = num1.lessThanOrEqual(num2);    // false
const isEqual = num1.equal(num2);                  // false
const isNotEqual = num1.notEqual(num2);            // true
```

## Contract Integration

### Storage Operations

```typescript
import { Storage } from '@as-stylus/as-stylus';

@Contract
class Counter {
    private value: Storage<U256>;
    
    constructor() {
        this.value = new Storage<U256>();
        this.value.set(U256Factory.create()); // Initialize to 0
    }
    
    @External
    increment(): void {
        const current = this.value.get();
        const one = U256Factory.fromString("1");
        const newValue = current.add(one);
        this.value.set(newValue);
    }
    
    @External
    decrement(): void {
        const current = this.value.get();
        const one = U256Factory.fromString("1");
        
        // Check if we can subtract (avoid underflow)
        if (current.greaterThanOrEqual(one)) {
            const newValue = current.sub(one);
            this.value.set(newValue);
        }
    }
    
    @External
    add(amount: U256): void {
        const current = this.value.get();
        const newValue = current.add(amount);
        this.value.set(newValue);
    }
    
    @View
    getValue(): U256 {
        return this.value.get();
    }
    
    @View
    getValueAsString(): string {
        return this.value.get().toString();
    }
}
```

### Event Logging

```typescript
@Event
class ValueChanged {
    oldValue: U256;
    newValue: U256;
}

@External
setValue(newValue: U256): void {
    const oldValue = this.value.get();
    this.value.set(newValue);
    
    // Emit change event
    const event = new ValueChanged();
    event.oldValue = oldValue;
    event.newValue = newValue;
    event.emit();
}
```

## Safe Operations

### Underflow Protection

```typescript
function safeSub(a: U256, b: U256): U256 {
    if (a.lessThan(b)) {
        revert("Subtraction would cause underflow");
    }
    return a.sub(b);
}
```

### Range Validation

```typescript
function validateRange(value: U256, min: U256, max: U256): void {
    if (value.lessThan(min)) {
        revert(`Value ${value.toString()} below minimum ${min.toString()}`);
    }
    if (value.greaterThan(max)) {
        revert(`Value ${value.toString()} above maximum ${max.toString()}`);
    }
}
```

## Error Handling

### Common Error Patterns

```typescript
@Error
class InvalidAmount {
    provided: U256;
    minimum: U256;
}

@Error
class InsufficientBalance {
    requested: U256;
    available: U256;
}

// Usage in validation
function requireMinimumAmount(amount: U256, minimum: U256): void {
    if (amount.lessThan(minimum)) {
        const error = new InvalidAmount();
        error.provided = amount;
        error.minimum = minimum;
        error.revert();
    }
}
```

## Best Practices

### Constants and Readability

```typescript
// Define commonly used values
const ZERO = U256Factory.create();
const ONE = U256Factory.fromString("1");
const HUNDRED = U256Factory.fromString("100");

// Descriptive function names
function isPositive(value: U256): boolean {
    return value.greaterThan(ZERO);
}

function isZero(value: U256): boolean {
    return value.equal(ZERO);
}
```

### Gas Optimization

```typescript
// Cache frequently used values
const zero = U256Factory.create();

// Efficient comparison patterns
function incrementIfNotZero(value: U256): U256 {
    if (value.greaterThan(zero)) {
        const one = U256Factory.fromString("1");
        return value.add(one);
    }
    return value;
}
```

## Common Use Cases

- **Token balances** and transfer amounts
- **Counters** and incrementing values
- **Financial calculations** with whole numbers
- **Voting systems** and tallying
- **Time-based calculations** (timestamps, durations)
- **Supply tracking** and inventory management

## Limitations

The current U256 interface does NOT include:
- Multiplication or division operations
- Bitwise operations
- Power/exponential functions
- Direct number conversion (must use strings)
- Specialized mathematical functions

For complex calculations requiring these operations, you'll need to implement them using the available add, sub, and modulo operations, or wait for expanded interface support.

## Related Types

- **I256**: For signed integers that support negative values
- **Address**: For Ethereum addresses and contract references
- **String**: For text-based data and user interfaces
- **Boolean**: For logical operations and conditional logic 